{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":4557669856379228919,"abi":{"parameters":[{"name":"user_key","type":{"kind":"field"},"visibility":"private"},{"name":"token_address","type":{"kind":"field"},"visibility":"public"},{"name":"amount","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"},{"kind":"array","length":4,"type":{"kind":"field"}}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VZ+3PTRhA+2wmQuDQmOLza8mxL29D2TvcUaQsU2kJ5v+FH3Un3Z/KnMawmupnlLMdKfPIMO/Pl1ivr0+63K83JGZB9ew/YJbM2aNbbzcqpEqLSWcU4K2iWWyOpkFYZZpg0sswM55URRuc21zRnglfMy5x7um8biIsuaX3muXn0PLM4UOe2DViLcv3Y+Btz/M3GD+eNAV8BTgK+buLh2JAs7h1dztiA9NM7slyeLA5gLbaadRIEGTVrfeBDFJugJIKNlktuJlks4iGHlEZDyrZIuoGfpKuRrjV6Dsispb5Rtw7I+7DcON9TfSZckw8XDNZhr3MqXQPZdsJ6+9Jwmyx+wh32Otsk7RMudd2Tpu5Fs7PIYt6U/T6dUEP8cK5575DPLbW+04T3UJ957hw9TxEH2nYneBcyRf4E+Tvk893JGcBZwDnA+Sbexn0GcZxF/jnkn4+4LwC+AXwL+O4AbpzfvF1VnPdFwCXAZcAVFA+WegMwTMh1kaSbqask7X0b9+Yq6sEl5F9G/pWoN9cA3wN+APx4QN8vII5rpNtu+jrgJ8DPgF/IbN9T37O7iCuzkjNbCW5dab2FTgpXGiMy55mBuLLO0tx565yzQmnnpc80y2lhaCVMq77XUa27HTW4AfgV8Bvg9xVoQBEXdaZkzFei4toWTrlCe81pocrSOG8qaWVlBS+oLYSUymTwx+kqr0pnrDe2TYMbqFbaUYP6QZ3VtQHECjSQeA4UU8xkhQSHai2oskVJJVzC8cJJLZUSnudcFN54LqXOCsUpz+FdgGaZ0G0aMFSr7KiBAmiAAeQr0OAmnoPcKmZFyQ2czqQUueVaqJKVeSYNd1TncGdU1vuK6VIypa3nRlalEtTARdo0UKjWmx012AP8AfgT8BeZ/6zZQxzjjty3mnrvAP4m/et7l6R7mz7qrxd3Iw3uAf4B/Av4bwUa3D+SBlqpXEmt4W+ltPTKwqe8TYP7qNZ7HefgAeB/wEPAIzJ/xh500Dfmfgx4AngKeNaRe9qR+zngBeAl4BXpv3evSbK9SLZIg9cdNXgDeAt4R/Z/LY01WPadLDI2SqjnLZL2vbavmtcS1jzuqeZR4llP+T6wnjCvx1+Ifgl/lWbHEub1fEX60eWMHU9Y815Crjc96Zf6vyInEuZZ5xbvs2oboljtH0OzUH9/vYnVvTzRcl6IbTTrJuIbpcs/C/zjfvjpcTJrm8gfR8dC/Wst5w3mfB5G60HfjeM4drLlWOA83aw431DHRrTuIN6EWrLAP+2Hv7VXO8ifRnVivW8nyiHwhWfmOpm1YXQsfDe+Zwbp82NxLqOWawULMzNFsaDnJyvZpSnGHwAA","debug_symbols":"7ZrbbqMwEIbfhetczIwPM86rrFZVDqRCQiQiyUqrqO++tMKAtC5ou6UVxncx/PyamU+x8ZhHdsz39+enojqdr9n2xyMrz4fdrThXzeiRwdul62VXvY6ut119y7ZG7CbLq2O2tSQvm+xUlHnzG182f0mVoVaq0XZSgYCUGL0tsYJxMTKrVozsaEIM5KNAsGYo/rnJMP4UKf4UVShFy6Z9grUeT5EE0cctCofixl3P6m5mdbezuvOs7jKru5vVHWFee5zXnv7Xnk1vb8y4WBRxKxbF/WzEoYlAAfkoFBgeF6MBL0ZDZlzs2HktEk5E8Q9zIon3pSb4iWlOQReEGkzMH1nZVGK4eIY6MVw8Q5MYfhpDK+BLYZ36OoY2MVz8/5ATw09j+F27dUkMF8/QRcJQlPZZipsSo4gXUwQQCeKASCA+S0JtVgYRE8TlQ4ykVUOK+tfCQUnWATGSXs26IepIIBru6meVWxnESLo164YYSbuG2EkXhl4bxEj6NeuGGGzY9BWZ5LKEHIMNDelAOozgAwtYQY7B7TCC7lp1MDhyWGyWtIosgxsqJOtXBBwePQSzROh7tDBYa4QCYuP8vsdqHpcuoXo6WD2l+rMY4VS996oX3EKgpm5l1wKpeu9Vz6bqfbR6zWBfF2VZPD8Nv+NtLv/a1cVuX+bt8HSvDoO7t98Xf8c/f6nPh/x4r/NXp7d7jf0f","file_map":{"61":{"source":"use dep::std;\r\n\r\nuse std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, fixed_base_scalar_mul, multi_scalar_mul};\r\nuse dep::poseidon::poseidon2::Poseidon2;\r\nuse dep::poseidon_ctr_encryption::{poseidon_ctr_encrypt};\r\nuse dep::ec::tecurve::affine::{Curve, Point};\r\nuse dep::ec::consts::te::{baby_jubjub};\r\nuse dep::indexed_merkle_tree::{\r\n    Leaf,\r\n    insert_item,\r\n    empty_root\r\n};\r\n\r\n\r\nmod test;\r\n\r\nfn main(\r\n    user_key: Field,\r\n    token_address: pub Field,\r\n    amount: pub Field,\r\n) -> pub (Field, Field, [Field; 4]) {\r\n  \r\n    let nonce_commitment = \r\n        Poseidon2::hash([user_key, 0 as Field], 2);\r\n    \r\n    let personal_imt_root = \r\n        create_initial_personal_indexed_tree(user_key, token_address, amount);\r\n\r\n    let main_indexed_tree_commitment = \r\n        Poseidon2::hash([personal_imt_root, nonce_commitment], 2);\r\n    \r\n    let user_key_hash = Poseidon2::hash([user_key], 1);\r\n    // === POSEIDON CTR MODE ENCRYPTION ===\r\n\r\n    let view_string = 0x76696577696e675f6b6579 as Field;\r\n    let view_key = Poseidon2::hash([view_string, user_key_hash], 2);\r\n    \r\n    // Encrypt amount, token_address, and personal IMT root\r\n    // We encrypt 3 fields: amount, token_address, personal_imt_root \r\n    let encrypted_amount = poseidon_ctr_encrypt(amount, view_key, 0);\r\n    let encrypted_token_address = poseidon_ctr_encrypt(token_address, view_key, 1);\r\n    let encrypted_personal_imt_root = poseidon_ctr_encrypt(personal_imt_root, view_key, 2);\r\n    \r\n    let encrypted_event = [encrypted_amount, encrypted_token_address, encrypted_personal_imt_root, 0];\r\n    \r\n    (        \r\n        main_indexed_tree_commitment,                      \r\n        nonce_commitment,\r\n        encrypted_event             \r\n    )\r\n}\r\n\r\n\r\n\r\nfn bjj_pub_key(priv_key: Field) -> Point {\r\n    // Create Baby Jubjub curve using std library\r\n    let bjj = baby_jubjub();\r\n    \r\n    // Get the base point (generator) from the curve\r\n    let base_pt = bjj.base8;\r\n\r\n    // Generate public key: public_key = private_key * base_point\r\n    bjj.curve.mul(priv_key, base_pt)\r\n}\r\n\r\nfn create_initial_personal_indexed_tree(\r\n    user_key: Field,\r\n    token_address: Field,\r\n    amount: Field\r\n) -> Field {\r\n    // === INDEXED MERKLE TREE FOR PERSONAL BALANCES ===\r\n    // Create a new indexed merkle tree to track user's token balances\r\n    // Key: token_address, Value: amount\r\n    \r\n    // Initialize with empty tree (zero item for exclusion proofs)\r\n    let mut leaves: [Leaf; 32] = [Leaf { key: 0, next_idx: 0, next_key: 0, value: 0 }; 32];\r\n    let mut num_leaves = 1; // Start with the zero item\r\n    \r\n    // Insert the initial balance entry\r\n    // Key = token_address, Value = amount\r\n    let (insertion_result, new_leaves, new_num_leaves) = insert_item(\r\n        leaves,\r\n        num_leaves,\r\n        token_address as u64,\r\n        amount\r\n    );\r\n    \r\n    // Return the new root after insertion\r\n    insertion_result.root_after\r\n}\r\n\r\n\r\n\r\n\r\n\r\n","path":"/home/drone/projects/ethrome25/circuits/main/nydus-entry/src/main.nr"},"70":{"source":"use dep::poseidon::poseidon2::Poseidon2;\r\n\r\nglobal MAX_DEPTH: u32 = 32;\r\n\r\npub struct Leaf {\r\n    pub key: u64,\r\n    pub next_idx: u32,\r\n    pub next_key: u64,\r\n    pub value: Field\r\n}\r\n\r\npub struct Proof {\r\n    pub leaf_idx: u32,\r\n    pub leaf: Leaf,\r\n    pub root: Field,\r\n    pub siblings: [Field; MAX_DEPTH]\r\n}\r\n\r\npub struct InsertionResult {\r\n    pub og_leaf_idx: u32,\r\n    pub og_leaf_key: u64,\r\n    pub og_leaf_next_idx: u32,\r\n    pub og_leaf_next_key: u64,\r\n    pub og_leaf_value: Field,\r\n    pub new_leaf_idx: u32,\r\n    pub new_leaf_key: u64,\r\n    pub new_leaf_value: Field,\r\n    pub root_before: Field,\r\n    pub root_after: Field,\r\n    pub siblings_before: [Field; MAX_DEPTH],\r\n    pub siblings_after_og: [Field; MAX_DEPTH],\r\n    pub siblings_after_new: [Field; MAX_DEPTH]\r\n}\r\n\r\npub fn empty_root() -> Field {\r\n    let zero_leaf = Leaf { key: 0, next_idx: 0, next_key: 0, value: 0 };\r\n    Poseidon2::hash([0, 0, 0, 0], 4)\r\n}\r\n\r\nfn hash_leaf(leaf: Leaf) -> Field {\r\n    Poseidon2::hash([\r\n        leaf.key as Field,\r\n        leaf.next_idx as Field,\r\n        leaf.next_key as Field,\r\n        leaf.value\r\n    ], 4)\r\n}\r\n\r\nfn hash_children(left: Field, right: Field) -> Field {\r\n    Poseidon2::hash([left, right], 2)\r\n}\r\n\r\npub fn compute_root(leaves: [Leaf; MAX_DEPTH], num_leaves: u32) -> Field {\r\n    let mut hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    let empty = empty_root();\r\n    \r\n    // Hash all leaves\r\n    for i in 0..MAX_DEPTH {\r\n        if i < num_leaves {\r\n            hashes[i] = hash_leaf(leaves[i]);\r\n        } else {\r\n            hashes[i] = empty;\r\n        }\r\n    }\r\n    \r\n    // Build tree bottom-up with fixed loop bounds\r\n    let mut current_hashes = hashes;\r\n    \r\n    // Level 0: 32 -> 16\r\n    let mut next_hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    for i in 0..16 {\r\n        next_hashes[i] = hash_children(current_hashes[i * 2], current_hashes[i * 2 + 1]);\r\n    }\r\n    current_hashes = next_hashes;\r\n    \r\n    // Level 1: 16 -> 8\r\n    let mut next_hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    for i in 0..8 {\r\n        next_hashes[i] = hash_children(current_hashes[i * 2], current_hashes[i * 2 + 1]);\r\n    }\r\n    current_hashes = next_hashes;\r\n    \r\n    // Level 2: 8 -> 4\r\n    let mut next_hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    for i in 0..4 {\r\n        next_hashes[i] = hash_children(current_hashes[i * 2], current_hashes[i * 2 + 1]);\r\n    }\r\n    current_hashes = next_hashes;\r\n    \r\n    // Level 3: 4 -> 2\r\n    let mut next_hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    for i in 0..2 {\r\n        next_hashes[i] = hash_children(current_hashes[i * 2], current_hashes[i * 2 + 1]);\r\n    }\r\n    current_hashes = next_hashes;\r\n    \r\n    // Level 4: 2 -> 1\r\n    let mut next_hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    next_hashes[0] = hash_children(current_hashes[0], current_hashes[1]);\r\n    \r\n    next_hashes[0]\r\n}\r\n\r\npub fn generate_proof(leaves: [Leaf; MAX_DEPTH], num_leaves: u32, leaf_idx: u32) -> Proof {\r\n    let leaf = leaves[leaf_idx];\r\n    let root = compute_root(leaves, num_leaves);\r\n    let mut siblings: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    let mut hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    let empty = empty_root();\r\n    \r\n    for i in 0..MAX_DEPTH {\r\n        if i < num_leaves {\r\n            hashes[i] = hash_leaf(leaves[i]);\r\n        } else {\r\n            hashes[i] = empty;\r\n        }\r\n    }\r\n    \r\n    let mut idx = leaf_idx;\r\n    \r\n    // Level 0: 32 -> 16\r\n    let sibling_idx = if idx % 2 == 0 { idx + 1 } else { idx - 1 };\r\n    siblings[0] = hashes[sibling_idx];\r\n    let mut new_hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    for i in 0..16 {\r\n        new_hashes[i] = hash_children(hashes[i * 2], hashes[i * 2 + 1]);\r\n    }\r\n    hashes = new_hashes;\r\n    idx = idx / 2;\r\n    \r\n    // Level 1: 16 -> 8\r\n    let sibling_idx = if idx % 2 == 0 { idx + 1 } else { idx - 1 };\r\n    siblings[1] = hashes[sibling_idx];\r\n    let mut new_hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    for i in 0..8 {\r\n        new_hashes[i] = hash_children(hashes[i * 2], hashes[i * 2 + 1]);\r\n    }\r\n    hashes = new_hashes;\r\n    idx = idx / 2;\r\n    \r\n    // Level 2: 8 -> 4\r\n    let sibling_idx = if idx % 2 == 0 { idx + 1 } else { idx - 1 };\r\n    siblings[2] = hashes[sibling_idx];\r\n    let mut new_hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    for i in 0..4 {\r\n        new_hashes[i] = hash_children(hashes[i * 2], hashes[i * 2 + 1]);\r\n    }\r\n    hashes = new_hashes;\r\n    idx = idx / 2;\r\n    \r\n    // Level 3: 4 -> 2\r\n    let sibling_idx = if idx % 2 == 0 { idx + 1 } else { idx - 1 };\r\n    siblings[3] = hashes[sibling_idx];\r\n    let mut new_hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    for i in 0..2 {\r\n        new_hashes[i] = hash_children(hashes[i * 2], hashes[i * 2 + 1]);\r\n    }\r\n    hashes = new_hashes;\r\n    idx = idx / 2;\r\n    \r\n    // Level 4: 2 -> 1\r\n    let sibling_idx = if idx % 2 == 0 { idx + 1 } else { idx - 1 };\r\n    siblings[4] = hashes[sibling_idx];\r\n    \r\n    Proof { leaf_idx: leaf_idx, leaf: leaf, root: root, siblings: siblings }\r\n}\r\n\r\npub fn verify_proof(proof: Proof) -> bool {\r\n    let mut current_hash = hash_leaf(proof.leaf);\r\n    let mut idx = proof.leaf_idx;\r\n    \r\n    for i in 0..5 {\r\n        if idx % 2 == 0 {\r\n            current_hash = hash_children(current_hash, proof.siblings[i]);\r\n        } else {\r\n            current_hash = hash_children(proof.siblings[i], current_hash);\r\n        }\r\n        idx = idx / 2;\r\n    }\r\n    \r\n    current_hash == proof.root\r\n}\r\n\r\npub fn verify_exclusion_proof(excluded_key: u64, proof: Proof) -> bool {\r\n    let is_after_leaf = excluded_key > proof.leaf.key;\r\n    let is_before_next = (proof.leaf.next_idx == 0) | (excluded_key < proof.leaf.next_key);\r\n    is_after_leaf & is_before_next\r\n}\r\n\r\npub fn verify_insertion_proof(insertion_result: InsertionResult) -> bool {\r\n    let og_leaf = Leaf {\r\n        key: insertion_result.og_leaf_key,\r\n        next_idx: insertion_result.og_leaf_next_idx,\r\n        next_key: insertion_result.og_leaf_next_key,\r\n        value: insertion_result.og_leaf_value\r\n    };\r\n    \r\n    let og_proof = Proof {\r\n        leaf_idx: insertion_result.og_leaf_idx,\r\n        leaf: og_leaf,\r\n        root: insertion_result.root_before,\r\n        siblings: insertion_result.siblings_before\r\n    };\r\n    \r\n    let new_leaf = Leaf {\r\n        key: insertion_result.new_leaf_key,\r\n        next_idx: 0,\r\n        next_key: 0,\r\n        value: insertion_result.new_leaf_value\r\n    };\r\n    \r\n    let new_proof = Proof {\r\n        leaf_idx: insertion_result.new_leaf_idx,\r\n        leaf: new_leaf,\r\n        root: insertion_result.root_after,\r\n        siblings: insertion_result.siblings_after_new\r\n    };\r\n    \r\n    verify_proof(og_proof) & verify_proof(new_proof)\r\n}\r\n\r\npub fn insert_item(\r\n    leaves: [Leaf; MAX_DEPTH],\r\n    num_leaves: u32,\r\n    new_key: u64,\r\n    new_value: Field\r\n) -> (InsertionResult, [Leaf; MAX_DEPTH], u32) {\r\n    // Find insertion position to maintain sorted order\r\n    let mut insert_idx = num_leaves; // Default to end\r\n    let mut prev_idx = 0;\r\n    \r\n    // Find the correct position for insertion (without break)\r\n    for i in 0..MAX_DEPTH {\r\n        let i_u32 = i as u32;\r\n        if i_u32 < num_leaves {\r\n            let is_greater = leaves[i].key > new_key;\r\n            let is_less_than_insert = i_u32 < insert_idx;\r\n            if is_greater & is_less_than_insert {\r\n                insert_idx = i_u32;\r\n            }\r\n            if i_u32 < insert_idx {\r\n                prev_idx = i_u32;\r\n            }\r\n        }\r\n    }\r\n    \r\n    let mut new_leaves = leaves;\r\n    let new_leaf_idx = num_leaves;\r\n    \r\n    // Create new leaf\r\n    let new_leaf = Leaf {\r\n        key: new_key,\r\n        next_idx: 0,\r\n        next_key: 0,\r\n        value: new_value\r\n    };\r\n    \r\n    // Insert at the end for now (simplified approach)\r\n    new_leaves[new_leaf_idx] = new_leaf;\r\n    \r\n    // Update previous leaf's next pointers if needed\r\n    if prev_idx < num_leaves {\r\n        new_leaves[prev_idx] = Leaf {\r\n            key: leaves[prev_idx].key,\r\n            next_idx: new_leaf_idx,\r\n            next_key: new_key,\r\n            value: leaves[prev_idx].value\r\n        };\r\n    }\r\n    \r\n    let new_count = num_leaves + 1;\r\n    \r\n    // Generate proofs\r\n    let og_proof = generate_proof(leaves, num_leaves, prev_idx);\r\n    let new_proof = generate_proof(new_leaves, new_count, new_leaf_idx);\r\n    let updated_prev_proof = generate_proof(new_leaves, new_count, prev_idx);\r\n    \r\n    let result = InsertionResult {\r\n        og_leaf_idx: og_proof.leaf_idx,\r\n        og_leaf_key: og_proof.leaf.key,\r\n        og_leaf_next_idx: og_proof.leaf.next_idx,\r\n        og_leaf_next_key: og_proof.leaf.next_key,\r\n        og_leaf_value: og_proof.leaf.value,\r\n        new_leaf_idx: new_proof.leaf_idx,\r\n        new_leaf_key: new_proof.leaf.key,\r\n        new_leaf_value: new_proof.leaf.value,\r\n        root_before: og_proof.root,\r\n        root_after: new_proof.root,\r\n        siblings_before: og_proof.siblings,\r\n        siblings_after_og: updated_prev_proof.siblings,\r\n        siblings_after_new: new_proof.siblings\r\n    };\r\n    \r\n    (result, new_leaves, new_count)\r\n}","path":"/home/drone/projects/ethrome25/circuits/lib/indexed-merkle-tree/src/indexed_merkle_tree.nr"},"80":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/drone/projects/ethrome25/circuits/lib/poseidon/src/poseidon2.nr"},"82":{"source":"use dep::std;\r\nuse dep::poseidon::poseidon2::Poseidon2;\r\n\r\n/// Poseidon CTR Mode Encryption Library\r\n/// \r\n/// This library provides Poseidon-based encryption in CTR mode for field elements.\r\n/// It includes functions for encrypting individual fields and batch encryption.\r\n\r\n/// Generate a keystream using Poseidon with shared_key and nonce\r\npub fn poseidon_keystream(shared_key: Field, nonce: u32) -> Field {\r\n    // === POSEIDON KEYSTREAM GENERATION ===\r\n    // Generate keystream using Poseidon with shared_key and nonce\r\n    \r\n    // Use the public hash function with shared_key and nonce\r\n    Poseidon2::hash([shared_key, nonce as Field], 2)\r\n}\r\n\r\n/// Encrypt a single field using Poseidon CTR mode\r\npub fn poseidon_ctr_encrypt(plaintext: Field, shared_key: Field, counter: u32) -> Field {\r\n    // === POSEIDON CTR MODE ENCRYPTION ===\r\n    // Use Poseidon to generate keystream for CTR mode encryption\r\n    \r\n    // Generate keystream using Poseidon with shared_key and counter\r\n    let keystream = poseidon_keystream(shared_key, counter);\r\n    \r\n    // Encrypt by adding keystream to plaintext (field arithmetic equivalent of XOR)\r\n    let ciphertext = plaintext + keystream;\r\n    \r\n    ciphertext\r\n}\r\n\r\n/// Decrypt a single field using Poseidon CTR mode\r\npub fn poseidon_ctr_decrypt(ciphertext: Field, shared_key: Field, counter: u32) -> Field {\r\n    // === POSEIDON CTR MODE DECRYPTION ===\r\n    // Decryption is the same as encryption in CTR mode\r\n    \r\n    // Generate the same keystream\r\n    let keystream = poseidon_keystream(shared_key, counter);\r\n    \r\n    // Decrypt by subtracting keystream from ciphertext\r\n    let plaintext = ciphertext - keystream;\r\n    \r\n    plaintext\r\n}\r\n\r\n/// Encrypt all four fields (amount, token_address, ref, encryption_key) in one function call\r\n/// This provides integrity checking - the ref value can be verified when absorbing the note\r\npub fn poseidon_encrypt_all_fields(\r\n    amount: Field, \r\n    token_address: Field,\r\n    ref: Field,\r\n    encryption_key: Field\r\n) -> (Field, Field, Field, Field) {\r\n    // === POSEIDON ENCRYPT ALL FIELDS ===\r\n    // Encrypt all four fields with different counters in one function call\r\n    // The ref value provides integrity checking when absorbing the note\r\n    \r\n    let encrypted_amount = poseidon_ctr_encrypt(amount, encryption_key, 0);\r\n    let encrypted_token_address = poseidon_ctr_encrypt(token_address, encryption_key, 1);\r\n    let encrypted_ref = poseidon_ctr_encrypt(ref, encryption_key, 2);\r\n    let encrypted_key = poseidon_ctr_encrypt(encryption_key, encryption_key, 3);\r\n    \r\n    (encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key)\r\n}\r\n\r\n/// Encrypt all four fields and return as array for cleaner API\r\npub fn poseidon_encrypt_all_fields_array(\r\n    amount: Field, \r\n    token_address: Field,\r\n    ref: Field,\r\n    encryption_key: Field\r\n) -> [Field; 3] {\r\n    // === POSEIDON ENCRYPT ALL FIELDS ARRAY ===\r\n    // Encrypt all four fields and return the first 3 as an array\r\n    // The ref value provides integrity checking when absorbing the note\r\n    \r\n    let encrypted_amount = poseidon_ctr_encrypt(amount, encryption_key, 0);\r\n    let encrypted_token_address = poseidon_ctr_encrypt(token_address, encryption_key, 1);\r\n    let encrypted_ref = poseidon_ctr_encrypt(ref, encryption_key, 2);\r\n    \r\n    [encrypted_amount, encrypted_token_address, encrypted_ref]\r\n}\r\n\r\n// ===== BASIC FUNCTIONALITY TESTS =====\r\n\r\n#[test]\r\nfn test_basic_encryption_decryption() {\r\n    // Test basic encryption and decryption round-trip\r\n    let plaintext = 12345 as Field;\r\n    let shared_key = Poseidon2::hash([42 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, shared_key, counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, shared_key, counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_zero_plaintext() {\r\n    // Test encryption of zero value\r\n    let plaintext = 0 as Field;\r\n    let shared_key = Poseidon2::hash([123 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, shared_key, counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, shared_key, counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_large_plaintext() {\r\n    // Test encryption of large field value (using a large but valid field value)\r\n    let plaintext = 21888242871839275222246405745257275088548364400416034343698204186575808495616 as Field; // p-1\r\n    let shared_key = Poseidon2::hash([456 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, shared_key, counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, shared_key, counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n// ===== COUNTER/KEYSTREAM TESTS =====\r\n\r\n#[test]\r\nfn test_different_counters_produce_different_ciphertexts() {\r\n    // Test that different counters produce different ciphertexts\r\n    let plaintext = 1000 as Field;\r\n    let shared_key = Poseidon2::hash([789 as Field], 1);\r\n    \r\n    let ciphertext1 = poseidon_ctr_encrypt(plaintext, shared_key, 0);\r\n    let ciphertext2 = poseidon_ctr_encrypt(plaintext, shared_key, 1);\r\n    let ciphertext3 = poseidon_ctr_encrypt(plaintext, shared_key, 2);\r\n    \r\n    // All ciphertexts should be different\r\n    assert(ciphertext1 != ciphertext2);\r\n    assert(ciphertext2 != ciphertext3);\r\n    assert(ciphertext1 != ciphertext3);\r\n    \r\n    // But all should decrypt to the same plaintext\r\n    assert(poseidon_ctr_decrypt(ciphertext1, shared_key, 0) == plaintext);\r\n    assert(poseidon_ctr_decrypt(ciphertext2, shared_key, 1) == plaintext);\r\n    assert(poseidon_ctr_decrypt(ciphertext3, shared_key, 2) == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_consistency() {\r\n    // Test that same inputs produce same keystream\r\n    let shared_key = Poseidon2::hash([999 as Field], 1);\r\n    let nonce = 5 as u32;\r\n    \r\n    let keystream1 = poseidon_keystream(shared_key, nonce);\r\n    let keystream2 = poseidon_keystream(shared_key, nonce);\r\n    \r\n    assert(keystream1 == keystream2);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_different_nonces() {\r\n    // Test that different nonces produce different keystreams\r\n    let shared_key = Poseidon2::hash([111 as Field], 1);\r\n    \r\n    let keystream1 = poseidon_keystream(shared_key, 0);\r\n    let keystream2 = poseidon_keystream(shared_key, 1);\r\n    let keystream3 = poseidon_keystream(shared_key, 2);\r\n    \r\n    assert(keystream1 != keystream2);\r\n    assert(keystream2 != keystream3);\r\n    assert(keystream1 != keystream3);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_different_keys() {\r\n    // Test that different keys produce different keystreams\r\n    let nonce = 0 as u32;\r\n    \r\n    let keystream1 = poseidon_keystream(Poseidon2::hash([1 as Field], 1), nonce);\r\n    let keystream2 = poseidon_keystream(Poseidon2::hash([2 as Field], 1), nonce);\r\n    let keystream3 = poseidon_keystream(Poseidon2::hash([3 as Field], 1), nonce);\r\n    \r\n    assert(keystream1 != keystream2);\r\n    assert(keystream2 != keystream3);\r\n    assert(keystream1 != keystream3);\r\n}\r\n\r\n// ===== BATCH ENCRYPTION TESTS =====\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_basic() {\r\n    // Test batch encryption of all four fields\r\n    let amount = 1000 as Field;\r\n    let token_address = 12345 as Field;\r\n    let ref = 67890 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    let (enc_amount, enc_token, enc_ref, enc_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, encryption_key\r\n    );\r\n    \r\n    // Verify each field can be decrypted individually\r\n    let dec_amount = poseidon_ctr_decrypt(enc_amount, encryption_key, 0);\r\n    let dec_token = poseidon_ctr_decrypt(enc_token, encryption_key, 1);\r\n    let dec_ref = poseidon_ctr_decrypt(enc_ref, encryption_key, 2);\r\n    let dec_key = poseidon_ctr_decrypt(enc_key, encryption_key, 3);\r\n    \r\n    assert(dec_amount == amount);\r\n    assert(dec_token == token_address);\r\n    assert(dec_ref == ref);\r\n    assert(dec_key == encryption_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_zero_values() {\r\n    // Test batch encryption with zero values\r\n    let amount = 0 as Field;\r\n    let token_address = 0 as Field;\r\n    let ref = 0 as Field;\r\n    let encryption_key = Poseidon2::hash([0 as Field], 1);\r\n    \r\n    let (enc_amount, enc_token, enc_ref, enc_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, encryption_key\r\n    );\r\n    \r\n    let dec_amount = poseidon_ctr_decrypt(enc_amount, encryption_key, 0);\r\n    let dec_token = poseidon_ctr_decrypt(enc_token, encryption_key, 1);\r\n    let dec_ref = poseidon_ctr_decrypt(enc_ref, encryption_key, 2);\r\n    let dec_key = poseidon_ctr_decrypt(enc_key, encryption_key, 3);\r\n    \r\n    assert(dec_amount == amount);\r\n    assert(dec_token == token_address);\r\n    assert(dec_ref == ref);\r\n    assert(dec_key == encryption_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_different_keys() {\r\n    // Test that different encryption keys produce different results\r\n    let amount = 1000 as Field;\r\n    let token_address = 2000 as Field;\r\n    let ref = 3000 as Field;\r\n    \r\n    let key1 = Poseidon2::hash([111 as Field], 1);\r\n    let key2 = Poseidon2::hash([222 as Field], 1);\r\n    \r\n    let (enc1_amount, enc1_token, enc1_ref, enc1_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, key1\r\n    );\r\n    \r\n    let (enc2_amount, enc2_token, enc2_ref, enc2_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, key2\r\n    );\r\n    \r\n    // Different keys should produce different ciphertexts\r\n    assert(enc1_amount != enc2_amount);\r\n    assert(enc1_token != enc2_token);\r\n    assert(enc1_ref != enc2_ref);\r\n    assert(enc1_key != enc2_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_integrity_check() {\r\n    // Test that the ref and key values provide integrity checking\r\n    let amount = 5000 as Field;\r\n    let token_address = 6000 as Field;\r\n    let ref = 7000 as Field;\r\n    let encryption_key = Poseidon2::hash([777 as Field], 1);\r\n    \r\n    let (enc_amount, enc_token, enc_ref, enc_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, encryption_key\r\n    );\r\n    \r\n    // Decrypt the ref and key values - they should match the original values\r\n    let decrypted_ref = poseidon_ctr_decrypt(enc_ref, encryption_key, 2);\r\n    let decrypted_key = poseidon_ctr_decrypt(enc_key, encryption_key, 3);\r\n    assert(decrypted_ref == ref);\r\n    assert(decrypted_key == encryption_key);\r\n    \r\n    // This provides integrity: if someone tries to use a different key to decrypt,\r\n    // the values won't match, indicating tampering\r\n    let wrong_key = Poseidon2::hash([888 as Field], 1);\r\n    let wrong_decrypted_ref = poseidon_ctr_decrypt(enc_ref, wrong_key, 2);\r\n    let wrong_decrypted_key = poseidon_ctr_decrypt(enc_key, wrong_key, 3);\r\n    assert(wrong_decrypted_ref != ref);\r\n    assert(wrong_decrypted_key != encryption_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_array() {\r\n    // Test the array version of encrypt all fields\r\n    let amount = 1000 as Field;\r\n    let token_address = 2000 as Field;\r\n    let ref = 3000 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    let encrypted_array = poseidon_encrypt_all_fields_array(amount, token_address, ref, encryption_key);\r\n    \r\n    // Verify array has 3 elements\r\n    assert(encrypted_array.len() == 3);\r\n    \r\n    // Verify each element can be decrypted\r\n    let dec_amount = poseidon_ctr_decrypt(encrypted_array[0], encryption_key, 0);\r\n    let dec_token = poseidon_ctr_decrypt(encrypted_array[1], encryption_key, 1);\r\n    let dec_ref = poseidon_ctr_decrypt(encrypted_array[2], encryption_key, 2);\r\n    \r\n    assert(dec_amount == amount);\r\n    assert(dec_token == token_address);\r\n    assert(dec_ref == ref);\r\n}\r\n\r\n// ===== SECURITY TESTS =====\r\n\r\n#[test]\r\nfn test_wrong_key_fails_decryption() {\r\n    // Test that decryption with wrong key fails\r\n    let plaintext = 5000 as Field;\r\n    let correct_key = Poseidon2::hash([111 as Field], 1);\r\n    let wrong_key = Poseidon2::hash([222 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, correct_key, counter);\r\n    let wrong_decrypted = poseidon_ctr_decrypt(ciphertext, wrong_key, counter);\r\n    \r\n    // Should not recover original plaintext\r\n    assert(wrong_decrypted != plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_wrong_counter_fails_decryption() {\r\n    // Test that decryption with wrong counter fails\r\n    let plaintext = 7777 as Field;\r\n    let shared_key = Poseidon2::hash([333 as Field], 1);\r\n    let correct_counter = 2 as u32;\r\n    let wrong_counter = 3 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, shared_key, correct_counter);\r\n    let wrong_decrypted = poseidon_ctr_decrypt(ciphertext, shared_key, wrong_counter);\r\n    \r\n    // Should not recover original plaintext\r\n    assert(wrong_decrypted != plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_encryption_deterministic() {\r\n    // Test that same inputs always produce same ciphertext\r\n    let plaintext = 8888 as Field;\r\n    let shared_key = Poseidon2::hash([444 as Field], 1);\r\n    let counter = 1 as u32;\r\n    \r\n    let ciphertext1 = poseidon_ctr_encrypt(plaintext, shared_key, counter);\r\n    let ciphertext2 = poseidon_ctr_encrypt(plaintext, shared_key, counter);\r\n    \r\n    // Same inputs should produce same ciphertext\r\n    assert(ciphertext1 == ciphertext2);\r\n}\r\n\r\n#[test]\r\nfn test_different_plaintexts_different_ciphertexts() {\r\n    // Test that different plaintexts produce different ciphertexts\r\n    let shared_key = Poseidon2::hash([555 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext1 = poseidon_ctr_encrypt(1000 as Field, shared_key, counter);\r\n    let ciphertext2 = poseidon_ctr_encrypt(2000 as Field, shared_key, counter);\r\n    let ciphertext3 = poseidon_ctr_encrypt(3000 as Field, shared_key, counter);\r\n    \r\n    // Different plaintexts should produce different ciphertexts\r\n    assert(ciphertext1 != ciphertext2);\r\n    assert(ciphertext2 != ciphertext3);\r\n    assert(ciphertext1 != ciphertext3);\r\n}\r\n\r\n// ===== EDGE CASE TESTS =====\r\n\r\n#[test]\r\nfn test_max_counter_value() {\r\n    // Test with maximum counter value\r\n    let plaintext = 1234 as Field;\r\n    let shared_key = Poseidon2::hash([666 as Field], 1);\r\n    let max_counter = 4294967295 as u32; // u32::MAX\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, shared_key, max_counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, shared_key, max_counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_encryption_preserves_field_arithmetic() {\r\n    // Test that encryption preserves field arithmetic properties\r\n    let a = 1000 as Field;\r\n    let b = 2000 as Field;\r\n    let shared_key = Poseidon2::hash([777 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    // Encrypt individual values\r\n    let enc_a = poseidon_ctr_encrypt(a, shared_key, counter);\r\n    let enc_b = poseidon_ctr_encrypt(b, shared_key, counter);\r\n    \r\n    // Decrypt and verify\r\n    let dec_a = poseidon_ctr_decrypt(enc_a, shared_key, counter);\r\n    let dec_b = poseidon_ctr_decrypt(enc_b, shared_key, counter);\r\n    \r\n    assert(dec_a == a);\r\n    assert(dec_b == b);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_uniformity() {\r\n    // Test that keystreams appear uniformly distributed\r\n    let shared_key = Poseidon2::hash([888 as Field], 1);\r\n    \r\n    let keystream1 = poseidon_keystream(shared_key, 0);\r\n    let keystream2 = poseidon_keystream(shared_key, 1);\r\n    let keystream3 = poseidon_keystream(shared_key, 2);\r\n    let keystream4 = poseidon_keystream(shared_key, 3);\r\n    let keystream5 = poseidon_keystream(shared_key, 4);\r\n    \r\n    // All keystreams should be different (very high probability)\r\n    assert(keystream1 != keystream2);\r\n    assert(keystream2 != keystream3);\r\n    assert(keystream3 != keystream4);\r\n    assert(keystream4 != keystream5);\r\n    assert(keystream1 != keystream3);\r\n    assert(keystream1 != keystream4);\r\n    assert(keystream1 != keystream5);\r\n    assert(keystream2 != keystream4);\r\n    assert(keystream2 != keystream5);\r\n    assert(keystream3 != keystream5);\r\n}\r\n\r\n// ===== TEST FOR TYPESCRIPT COMPARISON =====\r\n\r\n/// Get test values for TypeScript comparison\r\npub fn get_poseidon_ctr_test_values() -> (Field, Field, Field, Field, Field, Field, Field, Field) {\r\n    // Test values to compare with TypeScript implementation\r\n    let amount = 1000 as Field;\r\n    let token_address = 12345 as Field;\r\n    let ref = 67890 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    // Encrypt all fields\r\n    let (encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key) = \r\n        poseidon_encrypt_all_fields(amount, token_address, ref, encryption_key);\r\n    \r\n    // Return all values for external testing\r\n    (amount, token_address, ref, encryption_key, encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key)\r\n}\r\n\r\n#[test]\r\nfn test_poseidon_ctr_encryption_values() {\r\n    // Test values to compare with TypeScript implementation\r\n    let amount = 1000 as Field;\r\n    let token_address = 12345 as Field;\r\n    let ref = 67890 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    // Encrypt all fields\r\n    let (encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key) = \r\n        poseidon_encrypt_all_fields(amount, token_address, ref, encryption_key);\r\n    \r\n    // Decrypt all fields\r\n    let decrypted_amount = poseidon_ctr_decrypt(encrypted_amount, encryption_key, 0);\r\n    let decrypted_token_address = poseidon_ctr_decrypt(encrypted_token_address, encryption_key, 1);\r\n    let decrypted_ref = poseidon_ctr_decrypt(encrypted_ref, encryption_key, 2);\r\n    let decrypted_key = poseidon_ctr_decrypt(encrypted_key, encryption_key, 3);\r\n    \r\n    // Verify round-trip encryption/decryption\r\n    assert(decrypted_amount == amount);\r\n    assert(decrypted_token_address == token_address);\r\n    assert(decrypted_ref == ref);\r\n    assert(decrypted_key == encryption_key);\r\n    \r\n \r\n    println(\"Encrypted amount: 0x{:x}\");\r\n    println(encrypted_amount);\r\n    println(\"Encrypted token address: 0x{:x}\");\r\n    println(encrypted_token_address);\r\n    println(\"Encrypted ref: 0x{:x}\");\r\n    println(encrypted_ref);\r\n    println(\"Encrypted key: 0x{:x}\");\r\n    println(encrypted_key);\r\n    println(\"Decrypted amount: 0x{:x}\");\r\n    println(decrypted_amount);\r\n    println(\"Decrypted token address: 0x{:x}\");\r\n    println(decrypted_token_address);\r\n    println(\"Decrypted ref: 0x{:x}\");\r\n    println(decrypted_ref);\r\n    println(\"Decrypted key: 0x{:x}\");\r\n    println(decrypted_key);\r\n}\r\n","path":"/home/drone/projects/ethrome25/circuits/lib/poseidon-ctr-encryption/src/lib.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}